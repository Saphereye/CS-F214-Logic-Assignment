\hypertarget{md_Profiling_autotoc_md4}{}\doxysection{Goal}\label{md_Profiling_autotoc_md4}
The of this exercise is to optimise the code but also keeping in mind the size. A popular method of compiling usually is to replace a function call with body of function. But this can lead to large files if the function has been called numerous times.

Using above mentioned techniques, {\ttfamily g++} is able to compile our {\ttfamily C++} code. \hypertarget{md_Profiling_autotoc_md5}{}\doxysection{Tools}\label{md_Profiling_autotoc_md5}
For runtime of each function we used {\ttfamily chrono} library of C++ on the given system. This library provide high accuracy data, which was useful to record information with even small inputs.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ OS Name }&\cellcolor{\tableheadbgcolor}\textbf{ System Type }&\cellcolor{\tableheadbgcolor}\textbf{ Processor }&\cellcolor{\tableheadbgcolor}\textbf{ Usable Ram  }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ OS Name }&\cellcolor{\tableheadbgcolor}\textbf{ System Type }&\cellcolor{\tableheadbgcolor}\textbf{ Processor }&\cellcolor{\tableheadbgcolor}\textbf{ Usable Ram  }\\\cline{1-4}
\endhead
Windows 10 &x64-\/based &11th Gen Intel(\+R) Core(\+T\+M) i3-\/1115\+G4 @ 3.\+00\+G\+Hz, 2995 Mhz, 2 Core(s), 4 Logical Processor(s) &7.\+65 GB  \\\cline{1-4}
\end{longtabu}


For memory analysis of the program we used inbuilt memory analysis of Visual Studio on the given system. We chose this due to it\textquotesingle{}s high accuracy and descriptive output, which helped us understand the code better.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ OS Name }&\cellcolor{\tableheadbgcolor}\textbf{ System Type }&\cellcolor{\tableheadbgcolor}\textbf{ Processor }&\cellcolor{\tableheadbgcolor}\textbf{ Usable Ram  }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ OS Name }&\cellcolor{\tableheadbgcolor}\textbf{ System Type }&\cellcolor{\tableheadbgcolor}\textbf{ Processor }&\cellcolor{\tableheadbgcolor}\textbf{ Usable Ram  }\\\cline{1-4}
\endhead
Windows 11 &x64-\/based &Intel(\+R) Core(\+T\+M) i5-\/10300H C\+PU @ 2.\+50 G\+Hz, 2496 Mhz, 4 Core(\+S), 8 Logical Processor(s) &3.\+10 GB  \\\cline{1-4}
\end{longtabu}
\hypertarget{md_Profiling_autotoc_md6}{}\doxysection{Input}\label{md_Profiling_autotoc_md6}
A randomised input was generated each time using the given python script


\begin{DoxyCode}{0}
\DoxyCodeLine{import random}
\DoxyCodeLine{from tokenize import String}
\DoxyCodeLine{}
\DoxyCodeLine{"""}
\DoxyCodeLine{BNF for our expression}
\DoxyCodeLine{E := I | (E + E) | (E * E) | (E > E) | (\string~ E)}
\DoxyCodeLine{"""}
\DoxyCodeLine{heightOfParseTree: int = 15}
\DoxyCodeLine{}
\DoxyCodeLine{def randInfix(count: int) -\/> String:}
\DoxyCodeLine{    if count <= 1:}
\DoxyCodeLine{        return random.choice(list("abcdefghijklmnopqrstuvwxyz"))[0]}
\DoxyCodeLine{    else:}
\DoxyCodeLine{        case = random.randint(1, 4)}
\DoxyCodeLine{        if case == 1:}
\DoxyCodeLine{                return f"(\{randInfix(count-\/1)\}*\{randInfix(count-\/1)\})"}
\DoxyCodeLine{        elif case == 2:}
\DoxyCodeLine{                return f"(\{randInfix(count-\/1)\}+\{randInfix(count-\/1)\})"}
\DoxyCodeLine{        elif case == 3:}
\DoxyCodeLine{                return f"(\{randInfix(count-\/1)\}>\{randInfix(count-\/1)\})"}
\DoxyCodeLine{        elif case == 4:}
\DoxyCodeLine{                return f"(\string~\{randInfix(count-\/1)\})"}
\DoxyCodeLine{}
\DoxyCodeLine{infix = randInfix(heightOfParseTree)}
\DoxyCodeLine{}
\DoxyCodeLine{with open("InfixText.txt","w") as file:}
\DoxyCodeLine{    file.write(infix)}
\end{DoxyCode}
\hypertarget{md_Profiling_autotoc_md7}{}\doxysection{Execution}\label{md_Profiling_autotoc_md7}
The program was optimised with flags {\ttfamily -\/Os -\/O2}.

The {\ttfamily -\/Os} flag optimizes the size of the code. Whereas {\ttfamily -\/O2} optimizes for speed. Size optimization happens at the cost of speed. For example replacing with body of code instead of a call function.

For time analysis, each task was run {\ttfamily 1000} times and the average was considered. The following data was reveived

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{7}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Tree Height }&\cellcolor{\tableheadbgcolor}\textbf{ No. of Atoms }&\cellcolor{\tableheadbgcolor}\textbf{ Task 1 (ms) }&\cellcolor{\tableheadbgcolor}\textbf{ Task 2 (ms) }&\cellcolor{\tableheadbgcolor}\textbf{ Task 3 (ms) }&\cellcolor{\tableheadbgcolor}\textbf{ Task 4 (ms) }&\cellcolor{\tableheadbgcolor}\textbf{ Task 5 (ms)  }\\\cline{1-7}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Tree Height }&\cellcolor{\tableheadbgcolor}\textbf{ No. of Atoms }&\cellcolor{\tableheadbgcolor}\textbf{ Task 1 (ms) }&\cellcolor{\tableheadbgcolor}\textbf{ Task 2 (ms) }&\cellcolor{\tableheadbgcolor}\textbf{ Task 3 (ms) }&\cellcolor{\tableheadbgcolor}\textbf{ Task 4 (ms) }&\cellcolor{\tableheadbgcolor}\textbf{ Task 5 (ms)  }\\\cline{1-7}
\endhead
5 &10 &0.\+0047605 &0.\+0079753 &0.\+005358 &0.\+008284 &0.\+0054994  \\\cline{1-7}
5 &12 &0.\+0028622 &0.\+0055984 &0.\+009877 &0.\+0060635 &0.\+0086048  \\\cline{1-7}
10 &119 &0.\+0347532 &0.\+0581992 &0.\+0647751 &0.\+0625164 &0.\+0591974  \\\cline{1-7}
10 &191 &0.\+0478533 &0.\+0898297 &0.\+0969904 &0.\+090525 &0.\+0993498  \\\cline{1-7}
15 &2425 &0.\+189015 &0.\+549159 &0.\+615554 &0.\+625281 &0.\+609831  \\\cline{1-7}
15 &3425 &0.\+488783 &0.\+9894795 &1.\+60096 &1.\+51223 &1.\+44321  \\\cline{1-7}
17 &4554 &0.\+545341 &1.\+4298 &1.\+62267 &1.\+4522 &1.\+54193  \\\cline{1-7}
17 &8894 &0.\+500103 &1.\+51216 &1.\+62874 &1.\+55287 &1.\+555075  \\\cline{1-7}
18 &11137 &0.\+528771 &1.\+99178 &1.\+67444 &1.\+53555 &1.\+6110075  \\\cline{1-7}
20 &46394 &0.\+686642 &1.\+47442 &1.\+70191 &1.\+61959 &1.\+66694  \\\cline{1-7}
20 &65619 &0.\+513933 &1.\+45734 &1.\+73145 &1.\+55454 &1.\+50251  \\\cline{1-7}
\end{longtabu}
\hypertarget{md_Profiling_autotoc_md8}{}\doxysection{Data in Graphical Manner}\label{md_Profiling_autotoc_md8}
\hypertarget{md_Profiling_autotoc_md9}{}\doxysubsection{Number of atoms Vs time taken graph}\label{md_Profiling_autotoc_md9}
 
\begin{DoxyImage}
\includegraphics[width=\textwidth,height=\textheight/2,keepaspectratio=true]{task_vs_time.jpeg}
\doxyfigcaption{Number of atoms Vs time taken}
\end{DoxyImage}
  \hypertarget{md_Profiling_autotoc_md10}{}\doxysection{Analysis}\label{md_Profiling_autotoc_md10}
\hypertarget{md_Profiling_autotoc_md11}{}\doxysubsection{Time Analysis}\label{md_Profiling_autotoc_md11}
Until {\ttfamily 4554} atoms, the time taken rises sharply. This is followed by decrease in the rate of change and it levels down to a linear relation with constant increase in time taken as number of atoms increase.

One can observe sharp variations in data, which we consider as experimental error.

We can explain this linear increase with time complexity. As the algorithms traverse throughg each element/node, one can approximate them to be {\ttfamily O(n)}. 